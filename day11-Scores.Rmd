---
title: |
 | Statistical Adjustment in Observational Studies,
 | Assessment of Adjustment,
 | Matched Stratification for One and Multiple Variables.
date: '`r format(Sys.Date(), "%B %d, %Y")`'
author: |
  | ICPSR 2022 Session 2
  | Jake Bowers, Ben Hansen, Tom Leavitt
bibliography:
 - 'BIB/MasterBibliography.bib'
fontsize: 10pt
geometry: margin=1in
graphics: yes
biblio-style: authoryear-comp
biblatexoptions:
  - natbib=true
output:
  beamer_presentation:
    slide_level: 2
    keep_tex: true
    latex_engine: xelatex
    citation_package: biblatex
    template: icpsr.beamer
    incremental: true
    includes:
        in_header:
           - defs-all.sty
    md_extensions: +raw_attribute-tex_math_single_backslash+autolink_bare_uris+ascii_identifiers+tex_math_dollars
    pandoc_args: [ "--csl", "chicago-author-date.csl" ]
---


<!-- To show notes  -->
<!-- https://stackoverflow.com/questions/44906264/add-speaker-notes-to-beamer-presentations-using-rmarkdown -->

```{r setup1_env, echo=FALSE, include=FALSE}
library(here)
source(here::here("rmd_setup.R"))
```

```{r setup2_loadlibs, echo=FALSE, include=FALSE}
## Load all of the libraries that we will use when we compile this file
## We are using the renv system. So these will all be loaded from a local library directory
library(dplyr)
library(ggplot2)
library(coin)
library(RItools)
library(optmatch)
```


## Today

  1. Agenda:  Continue to think about an adjustment strategy to enhance
     counterfactual causal interpretations in non-randomized studies:
      - Workflow:
         a) choose basis or covariates that need adjusting $\rightarrow$
         b) create a stratification of the data / a stratified research design (ex. `fullmatch`) $\rightarrow$
         c) choose one or more approaches to evaluate the stratification (ex. `xBalance`) $\rightarrow$
         d) (probably) improve the stratified design / iterate 
      - How to do this with one variable?
      - How to do this with  more than one variable?
 2. We are now moving into the "Observational Studies" or Matching part of the course (see the reading there).
 3. Questions arising from the reading or assignments or life?

# But first, review after the weekend:

## Review of Instrumental Variables

Say you think you have an instrument: "rainfall", "economic liberalization as
a result of NAFTA", "a housing/school lottery". You then need to convince
yourself about:

 - SUTVA
 - "As if randomized"/Ignorability
 - That the instrument detectibly changes the dose / The instrument is not
   weak.
 - That the instrument influences the outcome **only** via the dose
   (Excludable)
 - (for *estimation* of CACE/LATE) That there are no defiers / the instrument
   changes the dose in one direction and the dose changes the outcome in one
   direction.

## Review of randomization assessment in a randomized experiment

How, in principle, might one do this? Notice that a wide variety of "imbalance" is consistent with a well randomized experiment:

```{r bal1, echo=TRUE}
library(MASS)
library(randomizr)
N <- 100
set.seed(1235)
xmat <- mvrnorm(n=N,mu=rep(0,N/2),Sigma=diag(N/2))
summary(as.vector(cor(xmat)))
dat <- data.frame(xmat)
dat$Z <- complete_ra(N=100,m=50)
xbFake <- xBalance(Z~.,data=dat,report="all")
xbFake$overall
xbFake_dat <- as.data.frame(xbFake$results)
xbFake_dat$varnm <- row.names(xbFake_dat)
xbFake_dat$varnmN <- 1:nrow(xbFake_dat)
```

## Review of randomization assessment in a randomized experiment

How, in principle, might one do this? Notice that a wide variety of "imbalance" is consistent with a well randomized experiment: (Line at 0=expected difference under randomization, lines are $\pm$ 2 sds of the randomization distribution of the null hypothesis of no difference.

```{r bal2, echo=FALSE, out.width=".7\\textwidth"}
g <- ggplot(data=xbFake_dat,aes(x=std.diff.unstrat,y=varnmN))+
    geom_point()+
    geom_segment(aes(x=-2*adj.diff.null.sd.unstrat,xend=2*adj.diff.null.sd.unstrat,y=varnmN,yend=varnmN)) +
    geom_vline(xintercept=0) +
xlab(label="Standardized Mean Difference") +
ylab(label="Covariate")

print(g)
```



## Review of linear model "control for"

Did the Metrocable intervention decrease
violence in those neighborhoods? We have Homicides per 1000 people in 2008 (`HomRate08`) as a function of Metrocable.

```{r echo=FALSE, cache=TRUE}
load(url("http://jakebowers.org/Data/meddat.rda"))
meddat <- mutate(meddat,
  HomRate03 = (HomCount2003 / Pop2003) * 1000,
  HomRate08 = (HomCount2008 / Pop2008) * 1000
)
row.names(meddat) <- meddat$nh
```

```{r lmraw, echo=TRUE}
lmRaw <- lm(HomRate08 ~ nhTrt, data = meddat)
coef(lmRaw)[["nhTrt"]]
```

What do we need to believe or know in order to imagine that we have done a good job adjusting for Proportion with more than HS Education below? (concerns about extrapolation, interpolation, linearity, influential points, parallel slopes, biased estimation of the average causal effect)

```{r lmadj1, echo=TRUE}
lmAdj1 <- lm(HomRate08 ~ nhTrt + nhAboveHS, data = meddat)
coef(lmAdj1)["nhTrt"]
```

What about when we try to adjust for more than one variable? (all of the other questions+the curse of
dimensionality)

```{r lmadj2, echo=TRUE}
lmAdj2 <- lm(HomRate08 ~ nhTrt + nhAboveHS + nhRent, data = meddat)
coef(lmAdj2)["nhTrt"]
```

## The Problem of Using  the Linear Model for  Adjustment

 - *Problem of Interepretability:* "Controlling for" is  "removing (additive) linear relationships" it is  not "holding constant"
 - *Problem of Diagnosis and Assessment:* What is the  standard against which we can compare a given linear covariance adjustment specification?
 - *Problem of extrapolation and interpolation:* Often known as "common support" plus "functional form dependence".
 - *Problems of overly influential points and curse of  dimensionality*: As dimensions increase, odds of influential  point increase (ex. bell curve in one dimension, one very influential point in 2 dimensions); also real limits on number of covariates (roughly $\sqrt{n}$ for OLS).
 - *Problems of  bias and assessing bias*:

\begin{equation}
Y_i = \beta_0 + \beta_1 Z_i + e_i
\end{equation}

This is a common practice because, we know that the formula to estimate $\beta_1$ in equation \ref{eq:olsbiv} is the same as the difference of means in $Y$ between treatment and control groups:

\begin{equation}
\hat{\beta}_1 = \overline{Y|Z=1} - \overline{Y|Z=0} = \frac{cov(Y,Z)}{var(Z)}. \label{eq:olsbiv}
\end{equation}

\begin{equation}
Y_i = \beta_0 + \beta_1 Z_i + \beta_2 X_i + e_i
\end{equation}

What is $\beta_1$ in this case? We know the matrix representation here $(\bX^{T}\bX)^{-1}\bX^{T}\by$, but here is the scalar formula for this particular case in \ref{eq:olsbiv}:

\begin{equation}
\hat{\beta}_1 = \frac{\var(X)\cov(Z,Y) - \cov(X,Z)\cov(X,Y)}{\var(Z)\var(X) - \cov(Z,X)^2}
\end{equation}

## The Problem of Using  the Linear Model for  Adjustment

 - Problems of  bias:

\begin{equation}
Y_i = \beta_0 + \beta_1 Z_i + e_i (\#eq:olsbiv)
\end{equation}

This is a common practice because, we know that the formula to estimate $\beta_1$ in equation \@ref(eq:olsbiv) is the same as the difference of means in $Y$ between treatment and control groups:

\begin{equation}
\hat{\beta}_1 = \overline{Y|Z=1} - \overline{Y|Z=0} = \frac{cov(Y,Z)}{var(Z)}.
\end{equation}

\begin{equation}
Y_i = \beta_0 + \beta_1 Z_i + \beta_2 X_i + e_i
\end{equation}

What is $\beta_1$ in this case? We know the matrix representation here $(\bX^{T}\bX)^{-1}\bX^{T}\by$, but here is the scalar formula for this particular case in \@ref{eq:olsbiv}:

\begin{equation}
\hat{\beta}_1 = \frac{\var(X)\cov(Z,Y) - \cov(X,Z)\cov(X,Y)}{\var(Z)\var(X) - \cov(Z,X)^2}
\end{equation}



# Matching on one variable to create strata

## Can we improve stratified adjustment?

Rather than two strata, why not three?

```{r lm1cut3, echo=TRUE}
meddat$nhAboveHScut3 <- cut(meddat$nhAboveHS,3)
lm1cut3 <- lm(HomRate08~nhTrt+nhAboveHScut3,data=meddat)
coef(lm1cut3)["nhTrt"]
```

Compare this stratification to a standard (the dist. we'd see if we had randomized `nhTrt` within each of those strata):

```{r lm1cut3ab, echo=TRUE}
xbcut3 <- xBalance(nhTrt~nhAboveHS,strata=list(unstrt=NULL,cut3=~nhAboveHScut3),data=meddat,report="all")
xbcut3$results
```

But why those cuts? And why not 4? Why not...?

\medskip

One idea: collect observations into strata such that the sum of the
differences in means of nhAboveHS within strata is smallest? This is the idea
behind `optmatch` and other matching approaches.

## The optmatch workflow: The distance matrix

*Introduction to `optmatch` workflow.* To minimize overall differences `optmatch` requires a matrix
of those differences (in general terms, a matrix of distances between the
treated and control units)

```{r optm1, echo=TRUE}
tmp <- meddat$nhAboveHS
names(tmp) <- rownames(meddat)
absdist <- match_on(tmp, z = meddat$nhTrt,data=meddat)
absdist[1:3,1:3]
abs(meddat$nhAboveHS[meddat$nhTrt==1][1] - meddat$nhAboveHS[meddat$nhTrt==0][1] )
```

## Created a Stratified Research Design

`fullmatch` and `pairmatch` use a distance matrix to produce strata.

```{r fm1, echo=TRUE}
fm1 <- fullmatch(absdist,data=meddat)
summary(fm1, min.controls=0, max.controls=Inf )
table(meddat$nhTrt,fm1)
pm1 <- pairmatch(absdist,data=meddat)
summary(pm1, min.controls=0, max.controls=Inf )
table(meddat$nhTrt,pm1,exclude=c())

fm2 <- fullmatch(absdist,data=meddat,min.controls=.5)

```


## Evaluate the design: Within set differences

```{r echo=FALSE}
meddat$fm1 <- fm1
meddat$pm1 <- pm1
```

Differences within sets versus raw differences.

```{r echo=FALSE, out.width=".9\\textwidth"}
library(gridExtra)
bpfm1 <- ggplot(meddat,aes(x=fm1,y=nhAboveHS)) +
	geom_boxplot() +
	 stat_summary(fun=mean, geom="point", shape=20, size=3, color="red", fill="red")
meddat$nostrata <- rep(1,45)
bporig <- ggplot(meddat,aes(x=nostrata,y=nhAboveHS))+
	 geom_boxplot()+
	 stat_summary(fun=mean, geom="point",
		      shape=20, size=3, color="red", fill="red")

grid.arrange(bpfm1,bporig,ncol=2,layout_matrix=matrix(c(1,1,1,1,2),nrow=1))
```

## Evaluate the design: Within-set differences
Differences within sets versus raw differences.

```{r echo=FALSE, out.width=".9\\textwidth"}
bppm1 <- ggplot(meddat,aes(x=pm1,y=nhAboveHS)) +
	geom_boxplot() +
	 stat_summary(fun=mean, geom="point", shape=20, size=3, color="red", fill="red")

grid.arrange(bppm1,bporig,ncol=2,layout_matrix=matrix(c(1,1,1,1,2),nrow=1))
```

## Evaluate the design: Inspect within-set differences

Use what we know about Medellin, about Metrocable, about neighborhoods there to assess the research design:

```{r sdiffs, echo=FALSE}
rawmndiffs <- with(meddat, mean(nhAboveHS[nhTrt==1]) - mean(nhAboveHS[nhTrt==0]))
setdiffsfm1 <- meddat %>% group_by(fm1) %>% summarize(mneddiffs =
						   mean(nhAboveHS[nhTrt==1]) -
						   mean(nhAboveHS[nhTrt==0]),
					   mnAboveHS = mean(nhAboveHS),
					   minAboveHS = min(nhAboveHS),
					   maxAboveHS = max(nhAboveHS))

setdiffsfm1 %>% arrange(desc(abs(mneddiffs)))
#summary(setdiffs$mneddiffs)
#quantile(setdiffs$mneddiffs, seq(0,1,.1))
```



## Evaluate the design: Inspect within set differences

Use what we know about Medellin, about Metrocable, about neighborhoods there to assess the research design:

```{r echo=FALSE, warnings=FALSE}
setdiffspm1 <- meddat %>% group_by(pm1) %>% summarize(mneddiffs =
						   mean(nhAboveHS[nhTrt==1]) -
						   mean(nhAboveHS[nhTrt==0]),
					   mnAboveHS = mean(nhAboveHS),
					   minAboveHS = min(nhAboveHS),
					   maxAboveHS = max(nhAboveHS))

setdiffspm1 %>% arrange(desc(abs(mneddiffs)))
```


## Evaluate the design: Compare to a randomized experiment.

The within-set differences look different from those that would be expected
from a randomized experiment.

```{r xbhs2, echo=TRUE}
xbfm1 <- xBalance(nhTrt~nhAboveHS,
                  strata=list(nostrat=NULL,
                              hsmatch=~fm1),
                  data=meddat,report="all")
xbfm1$results
xbfm1$overall
```



## What is xBalance doing?

```{r xbagain, echo=TRUE}
setmeanDiffs <- meddat %>% group_by(fm1) %>%
  summarise(diffAboveHS=mean(nhAboveHS[nhTrt==1])-mean(nhAboveHS[nhTrt==0]),
            nb=n(),
            nTb = sum(nhTrt),
            nCb = sum(1-nhTrt),
            hwt = ( 2*( nCb * nTb ) / (nTb + nCb))
            )
setmeanDiffs %>% arrange(desc(abs(diffAboveHS)))
```

## What is xBalance doing with multiple sets/blocks?

The test statistic is a weighted average of the set-specific differences (same
approach as we would use to test the null in a block-randomized experiment)

```{r wtmns, echo=TRUE}
## The descriptive mean difference using block-size weights
## with(setmeanDiffs, sum(diffAboveHS*nTb/sum(nTb)))
## The mean diff used as the observed value in the testing
with(setmeanDiffs, sum(diffAboveHS*hwt/sum(hwt)))
## Compare to xBalance output
xbfm1$results[,,"hsmatch"]
```

## What do we mean by "compare to a randomized experiment"?

Recall that $p$-values require distributions, and distributions require processes that can be repeated (even in a Bayesian formulation). What are we repeating in an experiment? (The assignment mechanism). 

```{r d1v2, echo=TRUE}
## This is another version that might be more clear in regards what is going on.
dstatv3 <- function(zz,mm,ss){
    dat <- data.frame(mm=mm,z=zz,s=ss)
    datb <- dat %>% group_by(s) %>% summarize(mndiff=mean(mm[z==1]) - mean(mm[z==0]),
        nb=n(),
        pib=mean(z),
        nbwt=nb/nrow(dat),
        hbwt0= pib * (1-pib) * nbwt)
    datb$hbwt <- datb$hbwt0/sum(datb$hbwt0)
    adjmn <- with(datb, sum(mndiff*hbwt))
    return(adjmn)
}
```

## What do we mean by "compare to a randomized experiment"?

Recall that $p$-values require distributions, and distributions require processes that can be repeated (even in a Bayesian formulation). What are we repeating in an experiment? (The assignment mechanism). 


```{r xbdist, messages=FALSE, warning=FALSE}
newexp <- function(zz,ss){
    ## newz <- unlist(lapply(split(zz,ss),sample),ss)
    newzdat <- data.frame(zz=zz,ss=ss) %>% group_by(ss) %>% mutate(newz=sample(zz))
    return(newzdat$newz)
}

set.seed(123455)
nulldist <- replicate(1000,with(meddat,dstatv3(zz=newexp(zz=nhTrt,ss=fm1),mm=nhAboveHS,ss=fm1)))
obsdstat <- with(meddat,dstatv3(zz=nhTrt,mm=nhAboveHS,ss=fm1))
2*min(mean(nulldist >=obsdstat), mean(nulldist <=obsdstat))
xbfm1$results
```


## What do we mean by "compare to a randomized experiment"?

Recall that $p$-values require distributions, and distributions require processes that can be repeated (even in a Bayesian formulation). What are we repeating in an experiment? (The assignment mechanism). 

```{r plotxbnulldist, out.width=".7\\textwidth"}
plot(density(nulldist))
rug(nulldist)
abline(v=obsdstat)
```

#  Matching on Many Covariates: Using Mahalnobis Distance

## Dimension reduction using the Mahalanobis Distance

The general idea: dimension reduction. When we convert many columns into one column we reduce the dimensions of the dataset (to one column). If using distance matrices and optimal matching allows us to side-step the problem of choosing cut-points for stratification, we can use the idea of **multivariate distance** to produce distance matrices to minimize **multivariate distances**.


```{r}
X <- meddat[, c("nhAboveHS", "nhPopD")]
plot(meddat$nhAboveHS, meddat$nhPopD, xlim = c(-.3, .6), ylim = c(50, 700))
```

## Dimension reduction using the Mahalanobis Distance

First, let's look at Euclidean distance: $\sqrt{ (x_1 - x_2)^2 + (y_1 - y_2)^2 }$

```{r echo=FALSE, out.width=".8\\textwidth"}
par(mgp = c(1.25, .5, 0), oma = rep(0, 4), mar = c(3, 3, 0, 0))
plot(meddat$nhAboveHS, meddat$nhPopD, xlim = c(-.3, .6), ylim = c(50, 700))
points(mean(X[, 1]), mean(X[, 2]), pch = 19, cex = 1)
arrows(mean(X[, 1]), mean(X[, 2]), X["407", 1], X["407", 2])
text(.4, 200, label = round(dist(rbind(colMeans(X), X["407", ])), 2))
```

## Dimension reduction using the Mahalanobis Distance

First, let's look at Euclidean distance: $\sqrt{ (x_1 - x_2)^2 + (y_1 - y_2)^2 }$

```{r echo=FALSE, out.width=".5\\textwidth"}
par(mgp = c(1.25, .5, 0), oma = rep(0, 4), mar = c(3, 3, 0, 0))
plot(meddat$nhAboveHS, meddat$nhPopD, xlim = c(-.3, .6), ylim = c(50, 700))
points(mean(X[, 1]), mean(X[, 2]), pch = 19, cex = 1)
arrows(mean(X[, 1]), mean(X[, 2]), X["407", 1], X["407", 2])
text(.4, 200, label = round(dist(rbind(colMeans(X), X["407", ])), 2))
```

Distance between point 0,0 and unit "407".

```{r}
tmp <- rbind(colMeans(X), X["407", ])
tmp
sqrt((tmp[1, 1] - tmp[2, 1])^2 + (tmp[1, 2] - tmp[2, 2])^2)
```

Problem: overweights variables with bigger scales (Population Density dominates).

## Dimension reduction using the Mahalanobis Distance

Now the Euclidean distance (on a standardized scale) so neither variable is overly dominant.

```{r echo=FALSE,out.width=".6\\textwidth"}
Xsd <- scale(X)
apply(Xsd, 2, sd)
apply(Xsd, 2, mean)
plot(Xsd[, 1], Xsd[, 2], xlab = "nhAboveHS/sd", ylab = "nhPopD/sd")
points(mean(Xsd[, 1]), mean(Xsd[, 2]), pch = 19, cex = 1)
arrows(mean(Xsd[, 1]), mean(Xsd[, 2]), Xsd["407", 1], Xsd["407", 2])
text(2, -1.2, label = round(dist(rbind(colMeans(Xsd), Xsd["407", ])), 2))
```


## Dimension reduction using the Mahalanobis Distance

The mahalanobis distance avoids the scale problem in the euclidean distance.^[For more [see here](https://stats.stackexchange.com/questions/62092/bottom-to-top-explanation-of-the-mahalanobis-distance)] Here each circle are points of the same MH distance.

```{r mhfig, echo=FALSE,out.width=".6\\textwidth"}
library(chemometrics)
par(mgp = c(1.5, .5, 0), oma = rep(0, 4), mar = c(3, 3, 0, 0))
mh <- mahalanobis(X, center = colMeans(X), cov = cov(X))
drawMahal(X,
  center = colMeans(X), covariance = cov(X),
  quantile = c(0.975, 0.75, 0.5, 0.25)
)
abline(v = mean(meddat$nhAboveHS), h = mean(meddat$nhPopD))
pts <- c("401", "407", "411", "202")
arrows(rep(mean(X[, 1]), 4), rep(mean(X[, 2]), 4), X[pts, 1], X[pts, 2])
text(X[pts, 1], X[pts, 2], labels = round(mh[pts], 2), pos = 1)
```

```{r}
Xsd <- scale(X)
tmp <- rbind(c(0, 0), Xsd["407", ])
mahalanobis(tmp, center = c(0, 0), cov = cov(Xsd))
edist <- sqrt((tmp[1, 1] - tmp[2, 1])^2 + (tmp[1, 2] - tmp[2, 2])^2)
edist
```

## Dimension reduction using the Mahalanobis Distance


```{r}
plot(Xsd[, 1], Xsd[, 2], xlab = "nhAboveHS/sd", ylab = "nhPopD/sd")
```

## Dimension reduction using the Mahalanobis Distance


```{r}
drawMahal(X, center = colMeans(X), covariance = cov(X), quantile = c(.1, .2))
```

```{r}
covX <- cov(X)
newcovX <- covX
newcovX[1, 2] <- 0
newcovX[2, 1] <- 0
```

## Dimension reduction using the Mahalanobis Distance


```{r}
drawMahal(X, center = colMeans(X), covariance = newcovX, quantile = c(.1, .2))
```

## Matching on the Mahalanobis Distance

Here using the rank based Mahalanobis distance following DOS Chap. 8 (but comparing to the ordinary version).

```{r}
mhdist <- match_on(nhTrt ~ nhPopD + nhAboveHS, data = meddat, method = "rank_mahalanobis")
mhdist[1:3, 1:3]
mhdist2 <- match_on(nhTrt ~ nhPopD + nhAboveHS, data = meddat)
mhdist2[1:3, 1:3]
mhdist2[, "407"]
```


```{r}
par(mgp = c(1.5, .5, 0), oma = rep(0, 4), mar = c(3, 3, 0, 0))
drawMahal(X,
  center = colMeans(X), covariance = cov(X),
  quantile = c(0.975, 0.75, 0.5, 0.25)
)
abline(v = mean(meddat$nhAboveHS), h = mean(meddat$nhPopD))
cpts <- c("401", "407", "411")
tpts <- c("101", "102", "202")
arrows(X[tpts, 1], X[tpts, 2], rep(X["407", 1]), rep(X["407", 2]))
text(X[tpts, 1], X[tpts, 2], labels = round(mhdist2[tpts, "407"], 2), pos = 1)
mhdist2[tpts, "407"]
```


## Matching on the Mahalanobis Distance

```{r}
fmMh <- fullmatch(mhdist, data = meddat)
summary(fmMh, min.controls = 0, max.controls = Inf)

fmMh1 <- fullmatch(mhdist, data = meddat, min.controls = 1)
summary(fmMh1, min.controls = 0, max.controls = Inf)
```

```{r}

xbMh <- xBalance(nhTrt ~ nhAboveHS + nhPopD, strata = list(unstrat = NULL, fmMh = ~fmMh, fmMh1 = ~fmMh1), report = "all", data = meddat)
xbMh
```


#  Matching on Many Covariates: Using Propensity Scores

## Matching on the propensity score

**Make the score**^[Note that we will be using `brglm` or `bayesglm` in the
future because of logit separation problems when the number of covariates
increases.]

```{r}
theglm <- glm(nhTrt ~ nhPopD + nhAboveHS + HomRate03, data = meddat, family = binomial(link = "logit"))
thepscore <- theglm$linear.predictor
thepscore01 <- predict(theglm, type = "response")
````

We tend to match on the linear predictor rather than the version required to
range only between 0 and 1.

```{r echo=FALSE, out.width=".7\\textwidth"}
par(mfrow = c(1, 2), oma = rep(0, 4), mar = c(3, 3, 2, 0), mgp = c(1.5, .5, 0))
boxplot(split(thepscore, meddat$nhTrt), main = "Linear Predictor (XB)")
stripchart(split(thepscore, meddat$nhTrt), add = TRUE, vertical = TRUE)

boxplot(split(thepscore01, meddat$nhTrt), main = "Inverse Link Function (g^-1(XB)")
stripchart(split(thepscore01, meddat$nhTrt), add = TRUE, vertical = TRUE)
```

## Matching on the propensity score

```{r}
psdist <- match_on(theglm, data = meddat)
psdist[1:4, 1:4]
fmPs <- fullmatch(psdist, data = meddat)
summary(fmPs, min.controls = 0, max.controls = Inf)
```

## Can you do better?

**Challenge:** Improve the matched design by adding covariates or functions of
covariates using either or both of the propensity score or mahalanobis distance
(rank- or not-rank based). So far we have:

```{r}
thecovs <- unique(c(names(meddat)[c(5:7, 9:24)], "HomRate03"))
balfmla <- reformulate(thecovs, response = "nhTrt")
xb5 <- xBalance(balfmla,
  strata = list(fmMh = ~fmMh, fmPs = ~fmPs),
  data = meddat, report = "all"
)
xb5$overall
```

```{r}

newexp <- function(z, block) {

}
```


## Can you do better?

Challenge: Improve the matched design. So far we have:

```{r}
plot(xb5)
```

## Summary:

What do you think?

 - Statistical adjustment with linear regression models is hard to justify.
 - Stratification via matching is easier to justify and assess (and describe).
 - Matching solves the problem of making comparisons that are transparent
   (Question: "Did you adjust enough for X?" Ans: "Here is some evidence about
   how well I did.")
 - You can adjust for one variable or more than one (if more than one, you
   need to choose one or more methods for reducing many columns to one
   column).
 - The workflow involves the creation of a distance matrix, asking an
   algorithm to find the best configuration of sets that minimize the
   distances within set, and checking balance. (Eventually, it will also be
   concerned about the effective sample size.)
  - Next: We will get more into the
   differences between full matching, optimal matching, greedy matching,
   matching with and without replacement, etc.. next week. (Also: handling
   missing data, calipers and other methods of improving design).
  - Next: How to estimate causal effects and test causal hypotheses with a
    matched design.



## References

