---
title: |
  | Statistical Adjustment and Assessment of Adjustment in Observational Studies and Nuts \& Bolts of Matching
date: '`r format(Sys.Date(), "%B %d, %Y")`'
author: |
  | ICPSR 2025 Session 1
  | Jake Bowers \& Ben Hansen \& Tom Leavitt
bibliography:
 - 'BIB/MasterBibliography.bib'
fontsize: 10pt
geometry: margin=1in
graphics: yes
biblio-style: authoryear-comp
colorlinks: true
biblatexoptions:
  - natbib=true
output:
  beamer_presentation:
    slide_level: 2
    keep_tex: true
    latex_engine: xelatex
    citation_package: biblatex
    template: styles/icpsr-beamer-template
    incremental: true
    includes:
        in_header:
           - defs-all.sty
    md_extensions: +raw_attribute-tex_math_single_backslash+autolink_bare_uris+ascii_identifiers+tex_math_dollars
    pandoc_args: [ "--csl", "chicago-author-date.csl" ]
---


<!-- To show notes  -->
<!-- https://stackoverflow.com/questions/44906264/add-speaker-notes-to-beamer-presentations-using-rmarkdown -->

```{r setup1_env, echo=FALSE, include=FALSE}
library(here)
source(here::here("rmd_setup.R"))
```

```{r setup2_loadlibs, echo=FALSE, include=FALSE}
## Load all of the libraries that we will use when we compile this file
## We are using the renv system. So these will all be loaded from a local library directory
library(dplyr)
library(ggplot2)
library(coin)
library(RItools)
library(optmatch)
```
## Today: Agenda

1. Agenda: The problem of covariance adjustment to reduce confounding. How can
   we answer the question about **whether we have adjusted enough** while
   avoiding extrapolation and dependence on functional form?

    1. A simple approach: stratification on one categorical variable (using
       weighted combinations of within-strata estimates for an overall
       estimate). Justify this **design** by comparison of this stratification
       with one or more **standards** of unconfounded designs (like an
       experiment with treatment randomized within strata).
    2. A more complex approach: find sets that are as similar as possible in
       terms of a continuous variable (bipartite matching). Balance assessment
       after stratification.

## Today: Recap

2. Recap: Problems of using linear (or other parametric models) for
   **adjustment** (as well as statistical inference):
   1. justifying variables,
   2. justifying functional forms (of $x_1 \rightarrow Z$ and $x_1 \rightarrow
      Y$ and $x_1 \rightarrow x_2$, and $f(x_1,x_2) \rightarrow Y$ and
      $f(x_1,x_2) \rightarrow Z$ and $f(x_1,x_2) \rightarrow x_3$),
   3. diagnosing and avoiding (or embracing if you believe the functional form)
      extrapolation and interpolation,
   4. diagnosing and confronting overly influential points,
   4. struggling with the problems of multiple testing and integrity arising
      from seeing the causal estimate and test results every time you try a new
      specification.
   5. And, basically, finding a **standard of adjustment** for such models
      where we can answer the question "have we adjusted enough"?
3. Questions arising from the reading or assignments or life?

# Strategies for Causal Inference

## Strategies and Workflow for randomized studies

### BEFORE fielding the study
- Plan the design for interpretability and power.
- Register your analysis plan (including hypotheses to be tested, estimands and
  estimates, etc.) and experimental design.

### AFTER outcome data have been collected
 - Make the case that randomization worked, check attrition, compliance,
   implementation. (In field experiments with long chains of responsibility, an
   important screening step even if not dispositive of a "failed experiment".
   Easier in other experiments.).
 - Increase precision with design and test statistics (and even models of
   effects)
 - Make sure that your estimator is estimating the right thing (i.e. is not
   biased or at least is consistent)
 - Make sure that your test has a controlled false positive rate and is as
   powerful as possible (i.e. the coverage rate of a confidence interval is
   nominal, the Type I error rate is controlled).

## Some Strategies for Adjustment of Observational Studies

- If you have randomized $Z$ but not $D$, then maybe $Z$ is an instrument for
  $D$ (IV). (Like an observational study within an experiment.)
- Find a discontinuity/A Natural Experiment (RDD: either natural experiment or
  continuous forcing function with assumptions about outcomes)
- Multiple controls each with different biases (i.e. "Choice as an alternative
  to control" see [@rosenbaum:1999])
- "Controlling For" directly in linear models, but lots of questions to
  answer...a lot of work...
- Difference in Differences (if you have some pre- and post-outcomes and can
  make assumptions about outcomes)
- Matched Stratification (approximating a block-randomized experiment with
  assumptions about covariates)
- Best matched subset selection (approximating a completely or simply
  randomized experiment)
- Weighting (the stratification approaches imply weightings, so we could try to
  calculate good weightings directly)
- Direct theoretical modeling / Directed Acyclic Graphs (DAGS) to guide other
  data modeling choices.
- And more! See the [Society for Causal Inference
  website](https://sci-info.org/) and the [Online Causal
  Inference](https://sites.google.com/view/ocis/home) workshop series.

# Recap

## Regression is not research design

Research design occurs **before** estimation and testing. You can try out
ideas, simulate, discuss, register your planned analysis and your design,
**before** you observe outcomes or produce the estimate or test result having to do
with some causal effect.

\smallskip

This means you should not see estimates and test results when you are looking for
a good design. Otherwise, when you present the result of a regression model
after searching for a specification, readers wonder:

1. is this just the best result out of thousands? Are most results like this?
   Or was this cherry picked?
2. how many $p$-values were looked at before reporting this one with $p < .05$?

## Jelly beans do not cause acne

:::::::::::::: {.columns}
::: {.column}

\includegraphics[width=.95\textwidth]{xkcd_significant_part1.png}

:::
::: {.column}
\includegraphics[width=\textwidth]{xkcd_significant_part2.png}
Probability of at least one false positive error in 20 tests is $1 - (1-.05)^{20}=.64$ **when jelly beans do not cause acne**.
(See [EGAP Guide on Multiple Comparisons](https://egap.org/resource/10-things-to-know-about-multiple-comparisons/)).


:::
::::::::::::::


## Regression is not research design

Say we want to describe the relationship between an outcome $y$, a focal explanatory
variable, $z$ and a potential confounder $x$ as a linear and additive function:
$y_i = \beta_0 + \beta_1 z_i + \beta_2 x_i$. What can we say about this?

1. "The **math implies** that the difference in $y$ between any two values of $z$ that differ by 1 must be the same regardless of which two values and regardless of the values that we plug-in for $x$." (Correct)
2. "The **math says** that relationship between differences in $z$ and differences in $y$ ($\frac{dy}{dz}$), is the same for all values of $z$ and $x$. This is a constant relation." (Correct)

## Regression is not research design


Say we fit that mathematical model, $y_i = \beta_0 + \beta_1 z_i + \beta_2 x_i$, to data. What can we say?

```{r, echo=FALSE, out.width=".5\\textwidth"}
load(here::here("day7_dat.rda"))
lm_Y_x1 <- lm(Y ~ x1, data = dat)
lm_Z_x1 <- lm(Z ~ x1, data = dat)
dat$resid_Y_x1 <- resid(lm_Y_x1)
dat$resid_Z_x1 <- resid(lm_Z_x1)
lm2 <- lm(Y~Z+x1,data=dat)
coef(lm2)
```

Here is a plot of Y-without-linear-x1 on X-without-linear-x1 with a slope of `r coef(lm2)[["Z"]]`.

```{r, echo=FALSE, out.width=".5\\textwidth",warning=FALSE}
g1 <- ggplot(dat,aes(x=resid_Z_x1,y=resid_Y_x1,color=x1))+geom_point()+geom_smooth(method="lm",se=FALSE)
print(g1)
```


## Regression is not research design {.shrink}


:::::::::::::: {.columns}
::: {.column}

```{r, echo=FALSE, out.width=".99\\textwidth",warning=FALSE}
g2 <- ggplot(dat,aes(x=x1,y=Y,color=factor(Z)),group=factor(Z))+geom_point()+
	geom_abline(intercept=coef(lm2)[["(Intercept)"]],slope=coef(lm2)[["x1"]])+
	geom_abline(intercept=(coef(lm2)[["(Intercept)"]]+coef(lm2)[["Z"]]),
		    slope=coef(lm2)[["x1"]],color="turquoise")

##print(g2)
library(cowplot)
plot_grid(g1,g2,ncol=1)
```

:::
::: {.column}
1. "Are we comparing $Y$ values with different $Z$ values but the same $x1$ value? Does our data fitting do the same thing as actually holding constant $x1$?" (No.)
2. "Does fitting our mathematical model to data do the same thing as physically holding constant?" (No.)
3. "Do predictions of $Y$ from our model for two values of $Z$ that are 1 apart differ by the same amount regardless of (a) which two values they are and (b) any value that we put in for $x$?" (Yes. This is because **we decided** to describe all of the relationships with a line.)
:::
::::::::::::::

<!--
## A 3D surface

Notice that the lines have the same slope as you move across the plane.

```{r, fig.keep="last", eval=FALSE}
library(rgl)
setupKnitr(autoprint = TRUE)
n <- 20
uniq_x <- seq(0,1,length=n)
uniq_z <- seq(0,1,length=n)
region <- expand.grid(x = uniq_x, z = uniq_z)
y <- matrix((region$x + region$z), n, n)
surface3d(x=uniq_x, y=uniq_z, z=y, back = 'line', front = 'line', col = 'red', lwd = 1.5, alpha = 0.4)
axes3d()
```
-->

## Recap summary:

- Correct interpretation of mathematical linear models may involve the word
  "constant" (after all, lines have constant slope, planes have constant slopes
  (one slope per dimension)).
- Mathematical linear models fit to data are not research designs. We learn
  which linear model fits the data best (where "best" can be defined in least
  squares ways for example), but we cannot learn whether confounding is linear
  from fitting such a model.
- Linear models estimate average treatment effects well (since OLS is a
  mean-difference calculator) and friendly software designers provide tests of
  the weak null of no average effects by default (that are valid given
  assumptions about standard errors and CLTs).
- \textcolor{blue}{Linear models are not research designs and should not be used as such.}
- Using linear models for adjustment might make sense if you are not worried
  about and/or have investigated: extrapolation, interpolation, functional
  form, influential points, and you have pre-specified your specification to
  avoid multiple testing problems and/or maybe generate a specification curve
  (of the millions of ways to specify the **adjustment part** of the linear
  model).



# How to assess the randomization process in an experiment (to teach us how to assess research designs in observational studies).

## The Neyman-Rubin Model for (simple) experiments

This is what randomization ensures:
$$ ({y_t, y_c},{X}) \perp {Z} $$

i.e., each of the distributions of $X$, $y_{c}$ and $y_{t}$ is balanced between treatment and control groups (in expectation; given variability from randomization).

- In controlled experiments, random assignment justifies this argument.
- In natural experiments, justified otherwise, this is an article of faith.
- In an experiment, the $x$es aren't necessary for inference (although
they can be used, carefully, to increase precision in both the design and
analysis phases of a project).
- **However, the part with the $x$es has testable consequences** if you worried about the success of the randomization --- say, the path between the random numbers on your computer and the application in the field.

## Covariate balance in experiments: What does it look like?

\begin{columns}
\begin{column}{.4\linewidth}
\begin{itemize}
\item \cite{arceneaux:2005}
\item Kansas City, November 2003
\item Completely randomized design: 14 precincts $\rightarrow$ Tx; 14 $\rightarrow $ Control.
\item Substantively large baseline differences (red dots)
\item<2-> Differences not large compared to other possible assignments from same design; compared to other possible experiments with the same design.
\item<2-> $\PP(\chi^{2} > x) = .91$ \citep{hansenbowers2008}. (grey lines)
\end{itemize}
\end{column}
\begin{column}{.6\linewidth}
\only<1>{\igrphx{KC-baseline}}
\only<2>{\igrphx{KC-bal+SDs}}
\end{column}
\end{columns}


## How did we do this?
```{r xb1, echo=TRUE}
acorn <- read.csv("data/acorn03.csv", row.names = 1)
xb1 <- balanceTest(z ~ v_p2003 + v_m2003 + v_g2002 + v_p2002 + v_m2002 + v_s2001 +
  v_g2000 + v_p2000 + v_m2000 + v_s1999 + v_m1999 + v_g1998 +
  v_m1998 + v_s1998 + v_m1997 + v_s1997 + v_g1996 + v_p1996 +
  v_m1996 + v_s1996 + size, p.adjust.method = "none",
data = acorn
)
```

## How did we do this? {.shrink}


```{r xb1_res, echo=TRUE}
xb1$results[,,]
```

## How did we do this?

```{r xb1overall, echo=TRUE}
xb1$overall
```


```{r, out.width=".7\\textwidth", warning=FALSE}
balplot0 <- plot(xb1,statistic="adj.diff",xlab="Differences in Proportion")
balplot0_dat <- balplot0$data
xb1_df <- as_tibble(xb1$results)
names(xb1_df) <- dimnames(xb1$results)$stat
xb1_df$rowname <- dimnames(xb1$results)$vars

balplot_dat <- left_join(balplot0_dat,xb1_df,by="rowname")

balplot1 <- ggplot(data=balplot_dat,aes(x=adj.diff*100,y=rowname)) +
    geom_point()+
    geom_linerange(aes(xmin=-pooled.sd*100,xmax=pooled.sd*100)) +
    xlim(c(-.1,.1)*100) +
    theme(legend.position = "none")

print(balplot1)
```

## Summary of Balance Assessment

- The design of randomized experiments imply certain known relationships with
  covariates.
- This provides a standard for comparison: are the covariates $\rightarrow$ $Z$
  relationships look typical of the design? Or weird/extreme?
- We can use $p$-values to measure "typicality" or "surprise" and randomization
  to generate the $p$-values.

## DeMystifying balanceTest {.shrink}

```{r d1, echo=TRUE}
d_stat <- function(zz, mm, ss) {
  ## this is the d_statistic (harmonic mean weighted diff of means statistic)
  ## from Hansen and Bowers 2008 almost directly from balanceTest.Engine
  h.fn <- function(n, m) {
    (m * (n - m)) / n
  }
  myssn <- apply(mm, 2, function(x) {
    sum((zz - unsplit(tapply(zz, ss, mean), ss)) * x)
  })
  hs <- tapply(zz, ss, function(z) {
    h.fn(m = sum(z), n = length(z))
  })
  mywtsum <- sum(hs)
  myadjdiff <- myssn / mywtsum
  return(myadjdiff)
}
```

## DeMystifying balanceTest

Recall our discussion of estimation "holding constant" within strata?

```{r d1v2, echo=TRUE}
## This is another version that might be more clear
d_stat_v2 <- function(zz, mm, ss) {
  ## mm is a data.frame
  dat <- cbind(mm, z = zz, s = ss)
  datb <- dat %>%
    group_by(s) %>%
    summarize(across(.cols = all_of(names(mm)), function(x) {
      mean(x[z == 1]) - mean(x[z == 0])
    }),
    nb = n(),
    pib = mean(z),
    nbwt = nb / nrow(dat),
    hbwt0 = pib * (1 - pib) * nbwt
    )
  datb$hbwt <- datb$hbwt0 / sum(datb$hbwt0)
  # datb[,15:27]
  adjmns <- datb %>% summarize(across(.cols = all_of(names(mm)), function(x) {
    sum(x * hbwt)
  }))
  adjmnsmat <- as.matrix(adjmns)
  return(adjmnsmat)
}
```

## DeMystifying balanceTest

```{r nullddistsetup, echo=TRUE}
acorncovs <- c("v_p2003", "v_m2003", "v_g2002", "v_p2002", "v_m2002", "v_s2001", "v_g2000", "v_p2000", "v_m2000", "v_s1999", "v_m1999", "v_g1998", "v_m1998", "v_s1998", "v_m1997", "v_s1997", "v_g1996", "v_p1996", "v_m1996", "v_s1996", "size")

dstats1 <- d_stat(zz = acorn$z, mm = acorn[, acorncovs], ss = rep(1, nrow(acorn)))
dstats2 <- d_stat_v2(zz = acorn$z, mm = acorn[, acorncovs], ss = rep(1, nrow(acorn)))

dstats1[1:5]
dstats2[1:5]
xb1$results[,"adj.diff",]

stopifnot(all.equal(dstats1, dstats2[1, ]))
```

```{r, eval=FALSE,echo=FALSE,results=FALSE}
## Curious whether one function is faster than the other
library(microbenchmark)
microbenchmark(d_stat(zz = acorn$z, mm = acorn[, acorncovs], ss = rep(1, nrow(acorn))),
  d_stat_v2(zz = acorn$z, mm = acorn[, acorncovs], ss = rep(1, nrow(acorn))),
  times = 100
)
```

## The reference distribution of the $d^2$ stat

For all vectors $z \in \Omega$ get `adj.diffs`. This is the distribution of the $d$ statistic for one-by-one balance assessment. Next question is about the distribution of the $d^2$ statistic: does it follow a $\chi^2$ distribution in this case?

```{r nulldist, cache=TRUE}
d_dist <- replicate(10000, d_stat(sample(acorn$z), acorn[, acorncovs], ss = rep(1, nrow(acorn))))
```

Get the randomization-based $p$-values:

```{r echo=TRUE}
xb1ds <- xb1$results[, "adj.diff", ]
xb1ps <- xb1$results[, "p", ]
obs.d <- d_stat(acorn$z, acorn[, acorncovs], rep(1, nrow(acorn)))
dps <- matrix(NA, nrow = length(obs.d), ncol = 1)
for (i in 1:length(obs.d)) {
  dps[i, ] <- 2 * min(mean(d_dist[i, ] >= obs.d[i]), mean(d_dist[i, ] <= obs.d[i]))
}
## You can compare this to the results from balanceTest
round(cbind(randinfps = dps[, 1], xbps = xb1ps, obsdstats = obs.d, xbdstats = xb1ds), 3)
```

## Reference distribution of the $d^2$ stat {.allowframebreaks}

The $d^2$ statistic is a linear function of the probably correlated $d$-statistics: a linear combination of correlated variables is $d^{T} \Sigma_d^{-1} d$ where $d$ is a vector of the stratum adjusted differences in means and $\Sigma_d$ is the variance-covariance matrix of the distribution of the $d$ statistics under the sharp null of no differences. With only one variable, this is basically a standardized $d$ statistic (after taking sqrt, and forced to be positive).

```{r d2stat, echo=TRUE}
d2_stat <- function(dstats, ddist = NULL, theinvcov = NULL) {
  ## d is the vector of d statistics
  ## ddist is the matrix of the null reference distributions of the d statistics
  if (is.null(theinvcov) & !is.null(ddist)) {
    as.numeric(t(dstats) %*% solve(cov(t(ddist))) %*% dstats)
  } else {
    as.numeric(t(dstats) %*% theinvcov %*% dstats)
  }
}
```

## Reference distribution of the $d^2$ stat

The distribution of the $d^2$ statistic arises from the distribution of the d statistics --- for each draw from the set of treatment assignments we can collapse the $d$-statistics into one $d^2$. And so we can calculate the $p$-value for the $d^2$.

```{r d22, echo=TRUE}
## Here we have the inverse of the covariance/variance matrix of the d statistics
invCovDDist <- solve(cov(t(d_dist)))
obs.d2 <- d2_stat(obs.d, d_dist, invCovDDist)

d2_dist <- apply(d_dist, 2, function(thed) {
  d2_stat(thed, theinvcov = invCovDDist)
})
## The chi-squared reference distribution only uses a one-sided p-value going in the positive direction
d2p <- mean(d2_dist >= obs.d2)
cbind(obs.d2, d2p)
xb1$overall
```


```{r, eval=FALSE, echo=FALSE, results=FALSE, out.width=".7\\textwidth"}
plot(density(d2_dist))
rug(d2_dist)
abline(v = obs.d2)
```


## Why differences between balanceTest and d2?

I suspect that $N=28$ is too small. `balanceTest` uses an asymptotic
approximation to the randomization distribution.

```{r echo=FALSE, out.width=".8\\textwidth", cache=FALSE}
#par(mfrow = c(1, 2),pty="m",oma=rep(0,4),mgp=c(1.5,.5,0),mar=c(3,3,0,0))
#qqplot(rchisq(10000, df = 21), d2_dist)
#abline(0, 1)
plot(density(d2_dist),main="",xlim=c(2,60))
rug(d2_dist)
lines(density(rchisq(10000, df = 21)),col="grey")
abline(v=c(obs.d2,xb1$overall$chisquare),col=c("black","grey"))
```

## Summary

 - Randomization balances covariate distributions between treated and control groups.
 - We can use randomization inference to check the randomization procedure (mostly useful if there is a long chain of communication between the random number generator and the field).
 - **Randomization does not imply exact equivalence. Large differences in covariates easily arise in small experiments.**

# Assessing comparisons in observational studies

```{r cache=TRUE}
load(url("http://jakebowers.org/Data/meddat.rda"))
```

##  Introducing the Medellin Data

Cerdá et al. collected data on about roughly `r nrow(meddat)`
neighborhoods in Medellin, Colombia. About  `r signif(sum(meddat$nhTrt),2)` had
access to the new Metrocable line and `r signif(sum(1-meddat$nhTrt),2)` did not.


\centering
\includegraphics[width=.7\textwidth]{medellin-gondola.jpg}

<!-- For more on the Metrocable project see <https://www.medellincolombia.co/where-to-stay-in-medellin/medellin-orientation/> and <https://archleague.org/article/connective-spaces-and-social-capital-in-medellin-by-jeff-geisinger/> -->


##  Introducing the Medellin Data

Cerdá et al. collected data on about roughly `r nrow(meddat)`
neighborhoods in Medellin, Colombia. About  `r signif(sum(meddat$nhTrt),2)` had
access to the new Metrocable line and `r signif(sum(1-meddat$nhTrt),2)` did not.

\centering
\includegraphics[width=.8\textwidth]{medellin-conc-pov.jpg}

##  Introducing the Medellin Data: Variables Collected

\scriptsize
```
## The Intervention
nhTrt        Intervention neighborhood (0=no Metrocable station, 1=Metrocable station)

## Some Covariates (there are others, see the paper itself)
nh03         Neighborhood id
nhGroup      Treatment (T) or Control (C)
nhTrt        Treatment (1) or Control (0)
nhHom        Mean homicide rate per 100,000 population in 2003
nhDistCenter Distance to city center (km)
nhLogHom     Log Homicide (i.e. log(nhHom))

## Outcomes (BE03,CE03,PV03,QP03,TP03 are baseline versions)
BE      Neighborhood amenities Score 2008
CE      Collective Efficacy Score 2008
PV      Perceived Violence Score 2008
QP      Trust in local agencies Score 2008
TP      Reliance on police Score 2008
hom     Homicide rate per 100,000 population Score 2008-2003 (in log odds)

HomCount2003 Number of homicides in 2003
Pop2003      Population in 2003
HomCount2008 Number of homicides in 2008
Pop2008      Population in 2008
```

Get rates from counts:

```{r rates, echo=TRUE}
meddat <- mutate(meddat,
  HomRate03 = (HomCount2003 / Pop2003) * 1000,
  HomRate08 = (HomCount2008 / Pop2008) * 1000
)
```

## What is the effect of the Metrocable on Homicides? {.allowframebreaks}

One approach:  Estimate the average treatment effect of Metrocable on
Homicides after the stations were built.

```{r lmone, echo=TRUE}
## code here
themeans <- group_by(meddat, nhTrt) %>%
  summarise(ybar = mean(HomRate08))
diff(themeans$ybar)
lmOne <- lm(HomRate08 ~ nhTrt, meddat)
coef(lmOne)["nhTrt"]
library(estimatr)
difference_in_means(HomRate08 ~ nhTrt, meddat)
```

Another approach, test the null of no effects:

```{r initialtest, echo=TRUE}
balanceTest(nhTrt ~ HomRate08, data = meddat)
meddat$nhTrtF <- factor(meddat$nhTrt)
test2 <- oneway_test(HomRate08 ~ nhTrtF, data = meddat, distribution = asymptotic())
test3 <- oneway_test(HomRate08 ~ nhTrtF, data = meddat, distribution = approximate(nresample = 1000))
test4 <- wilcox_test(HomRate08 ~ nhTrtF, data = meddat, distribution = approximate(nresample = 1000))
pvalue(test2)
pvalue(test3)
pvalue(test4)
```

## Do we have any concerns about confounding?

Sometimes people ask about "bias from observed confounding" or "bias from selection on observables".

\smallskip

How would we interpret the following results where `nhAboveHS` is proportion
with more than a high school education in the neighborhood in 2003 or so and
`nhTrt` is 0=no station built, 1=station built? (Recall how we justified the
use of `balanceTest` in terms of randomization above.)

```{r xbmed, echo=TRUE}
xbMed1 <- balanceTest(nhTrt ~ nhAboveHS, data = meddat)
xbMed1$overall
xbMed1$results[,,]
```

## How would you adjust for Proportion Above HS Degree?

Part of the Metrocable effect is not about Metrocable per se, but rather about
the education of people in the neighborhood. How should we remove `nhAboveHS`
from our estimate or test? What strategies can you think of?


## One approach to this problem: model-based adjustment

Let's try to just adjust for this covariate in a very common manner:

```{r echo=FALSE}
lm1 <- lm(HomRate08 ~ nhTrt + nhAboveHS, data = meddat)
```

```{r echo=FALSE}
preddat <- expand.grid(nhTrt = c(0, 1), nhAboveHS = range(meddat$nhAboveHS))
preddat$fit <- predict(lm1, newdata = preddat)
```

\centering
```{r, out.width=".9\\textwidth", echo=FALSE}
par(oma = rep(0, 4), mgp = c(1.5, .5, 0), mar = c(3, 3, 0, 0))
with(meddat, plot(nhAboveHS, HomRate08, pch = c(1, 2)[nhTrt + 1]))
with(subset(preddat, subset = nhTrt == 0), lines(nhAboveHS, fit, lty = 1))
with(subset(preddat, subset = nhTrt == 1), lines(nhAboveHS, fit, lty = 2))
## locator()
text(c(0.111807, 0.001629), c(1.871, 2.204), labels = c("Treat", "Control"), pos = 1)
text(c(.3, .5), c(coef(lm1)[1] + coef(lm1)[3] * .3, coef(lm1)[1] + coef(lm1)[2] + coef(lm1)[3] * .5),
  labels = c("Control", "Treat")
)
```

## Exactly what does this kind of adjustment do?

Notice that I can get the same coefficient (the effect of Metrocable on
Homicides adjusted for HS-Education in the neighborhood) either directly (as
earlier) or via **residualization**:

```{r echo=TRUE}
coef(lm1)["nhTrt"]
eYX <- residuals(lm(HomRate08 ~ nhAboveHS, data = meddat))
eZX <- residuals(lm(nhTrt ~ nhAboveHS, data = meddat))
lm1a <- lm(eYX ~ eZX)
coef(lm1a)[2]
```

## Exactly what does this kind of adjustment do?

So, how would you explain what it means to "control for HS-Education" here?

```{r}
plot(eZX, eYX)
```



## Did we adjust enough?

Maybe adding some more information to the plot can help us decide whether, and to what extend, we effectively "controlled for" the proportion of the neighborhood with more than High School education. Specifically, we might be interested in assessing extrapolation/interpolation problems arising from our linear assumptions.

\centering
```{r, out.width=".6\\textwidth", echo=FALSE, warning=FALSE, message=FALSE}
par(oma = rep(0, 4), mgp = c(1.5, .5, 0), mar = c(3, 3, 0, 0))
with(meddat, plot(nhAboveHS, HomRate08, pch = c(1, 2)[nhTrt + 1]))
with(subset(preddat, subset = nhTrt == 0), lines(nhAboveHS, fit, lty = 1))
with(subset(preddat, subset = nhTrt == 1), lines(nhAboveHS, fit, lty = 2))
with(subset(meddat, subset = nhTrt == 0), lines(loess.smooth(nhAboveHS, HomRate08, deg = 1, span = 2 / 3), lty = 1))
with(subset(meddat, subset = nhTrt == 1), lines(loess.smooth(nhAboveHS, HomRate08, deg = 1, span = .8), lty = 2))
## locator()
text(c(0.111807, 0.001629), c(1.871, 2.204), labels = c("Treat", "Control"), pos = 1)
text(c(.3, .5), c(coef(lm1)[1] + coef(lm1)[3] * .3, coef(lm1)[1] + coef(lm1)[2] + coef(lm1)[3] * .5),
  labels = c("Control", "Treat")
)
with(subset(meddat, subset = nhTrt == 0), rug(nhAboveHS))
with(subset(meddat, subset = nhTrt == 1), rug(nhAboveHS, line = -.5))
```

How should we interpret this adjustment? How should we judge the improvement that we made? What concerns might we have?

```{r echo=FALSE, eval=FALSE}
thecovs <- unique(c(names(meddat)[c(5:7, 9:24)], "HomRate03"))
balfmla <- reformulate(thecovs, response = "nhTrt")

xbMed <- balanceTest(balfmla,
  data = meddat,
  p.adjust.method = "none"
)
xbMed$overall
xbMed$results["nhAboveHS", , ]
```


```{r echo=FALSE, eval=FALSE}
outcomefmla <- reformulate(c("nhTrt", thecovs), response = "HomRate08")
lmbig <- lm(outcomefmla, data = meddat)
```


## How would you adjust for Proportion Above HS Degree?

So, part of the Metrocable effect might not reflect the causal effect of
Metrocable per se, but rather the education of people in the
neighborhood. How should we remove `nhAboveHS` from our estimate or test? What
strategies can you think of?

Features of a good adjustment process:

  - Blind to outcome analysis (to preserve false positive rate and deter
    critics). Able to be pre-registered. Perhaps even reviewed by stakeholders.
  - Easy to interpret ("controlling for by removing linear additive
    relationships"  versus "holding constant by comparing units with same
    values")
  - Easy to diagnose (Easy to answer the question "Did we adjust enough?")

## Stratification V 1.0

```{r strat1, echo=TRUE}
meddat$nh_high_hs <- as.numeric(meddat$nhAboveHS >= .1)
lm1a <- lm(HomRate08 ~ nhTrt, data = meddat, subset = nhAboveHS >= .1)
lm1b <- lm(HomRate08 ~ nhTrt, data = meddat, subset = nhAboveHS < .1)
res_strat <- c(hiEd_Effect = coef(lm1a)["nhTrt"], loEd_Effect = coef(lm1b)["nhTrt"])
res_strat
n_strat <- table(meddat$nhAboveHS >= .1)
n_strat
stopifnot(sum(n_strat) == nrow(meddat)) ## A test of code
sum(res_strat * rev(n_strat) / 45) ## What is happening here?
```

## Stratification V 1.0

```{r strat1a, echo=TRUE}
## Putting this together
outcome_analysis_strat <- meddat %>% group_by(nhAboveHS>=.1) %>%
  summarize(nb=n(),
            nT=sum(nhTrt),
            nC=nb-nT,
            pr_trt=mean(nhTrt),
            bar_y_t=mean(HomRate08[nhTrt==1]),
            bar_y_c=mean(HomRate08[nhTrt==0]),
            ate_b=bar_y_t - bar_y_c)

outcome_analysis_strat <- outcome_analysis_strat %>% mutate(nbwt=nb/sum(nb),
    prec_wt0 = nbwt * pr_trt * (1-pr_trt))
outcome_analysis_strat$prec_wt <-
    with(outcome_analysis_strat,prec_wt0/sum(prec_wt0))

outcome_analysis_strat

outcome_analysis_strat %>% summarize(ate_block_size= sum(ate_b * nbwt),
    ate_prec_wt = sum(ate_b * prec_wt/sum(prec_wt)))

```

*But, standard errors? p-values? confidence intervals?*

## Stratified adjustment V 2.0 {.allowframebreaks}

One-step stratified estimation.

```{r strat2, echo=TRUE}
## Create individual level weights as a check on the more convenient functions below
meddat2 <- meddat %>% group_by(nh_high_hs) %>%
  mutate(nb=n(),
         prob_trt = mean(nhTrt),
         ate_wt=nhTrt/(prob_trt) + (1-nhTrt)/(1-prob_trt)) %>% ungroup()

## Weight by block size
ate1c <- difference_in_means(HomRate08 ~ nhTrt, blocks = nh_high_hs, data = meddat2)
coef(ate1c)[["nhTrt"]]
## Using propertee
library(propertee)
med_spec <- obs_spec(nhTrt~unit_of_assignment(nh03)+block(nh_high_hs),data=meddat2)
specification_table(med_spec,"treatment","blocks")
ate1e <- lm(HomRate08~nhTrt,data=meddat2,weights=ate(med_spec))
coef(ate1e)[[2]]
ate1f <- lmitt(HomRate08~1,data=meddat2,specification=med_spec,weights="ate")
coef(ate1f)[["nhTrt."]]

ate1g <- lmitt(HomRate08~1,data=meddat2,specification=nhTrt~uoa(nh03)+block(nh_high_hs),weights="ate")
coef(ate1g)[["nhTrt."]]

## Directly weighting by probability of treatment
ate1h <- lm(HomRate08~nhTrt,data=meddat2,weights=ate_wt)
coef(ate1h)[["nhTrt"]]

### The precision weighting versions
## Weight by both block size and  proportion in treatment vs control ("harmonic weight")
lm1c <- lm_robust(HomRate08 ~ nhTrt, fixed_effects = ~ nh_high_hs, data = meddat)
coef(lm1c)["nhTrt"]
## This is the least squares dummy variable version
lm1d <- lm(HomRate08 ~ nhTrt + nh_high_hs, data = meddat)
coef(lm1d)["nhTrt"]
```

## Stratified adjustment and Testing V 2.0 {.allowframebreaks}

One-step stratified testing

```{r echo=TRUE}
xbate1 <- balanceTest(nhTrt ~ HomRate08+ strata(nh_high_hs), data = meddat2)
xbate1$results[, c("adj.diff","p"), ]
xbate1$overall

## Effect of the treatment on the treated weights (see the "adj.diff" column from balanceTest)
outcome_analysis_strat$nTwt <- with(outcome_analysis_strat,nT/sum(nT))
with(outcome_analysis_strat,sum(ate_b*nTwt))
lm_ett <- lmitt(HomRate08~1,specification=med_spec,data=meddat2,weight="ett")
coef(lm_ett)[["nhTrt."]]

## Approximating the as-if-randomized null distribution with a Normal
## approximation
hstest2 <- independence_test(HomRate08~nhTrt|factor(nh_high_hs),data=meddat)

## Now using the "as-if-randomized" distribution directly
set.seed(12345)
hstest2_perm <- independence_test(HomRate08~nhTrt|factor(nh_high_hs),data=meddat,distribution=approximate(nresample=10000))

pvalue(hstest2)
pvalue(hstest2_perm)

## Now trying different test statistics
hstest4 <- independence_test(HomRate08~nhTrt|factor(nh_high_hs),data=meddat,ytrafo=rank_trafo)
pvalue(hstest4)

hstest5 <- wilcox_test(HomRate08~factor(nhTrt)|factor(nh_high_hs),data=meddat)
pvalue(hstest5)

```

## Balance assessment after stratification

Did we adjust enough? What would *enough* mean? Use the testing approach but now focus only on the covariate(s) that you are trying to adjust.

```{r xbHS1, echo=TRUE}
xbHS1 <- balanceTest(nhTrt ~ nhAboveHS+strata(I(nh_high_hs)), data = meddat)
xbHS1$overall
xbHS1$results[1, c("Treatment", "Control", "adj.diff", "std.diff", "z", "p"), ] ## the covariate specific z-test
```

## Disadvantages and Advantages of Simple Stratification

  -  (+) Easy to explain what  "controlling for" or "adjustment" means.
  -  (-) Hard to justify any particular cut-point
  -  (-) We could probably adjust *more* on education --- comparing neighborhoods similar in
    education rather than just  within  big   strata
  -  (-) We might want to adjust for more than one covariate.

<!--

## The Problem of Using  the Linear Model for  Adjustment

 - Problem of Interepretability: "Controlling for" is  "removing (additive)
   linear relationships" it is  not "holding constant"
 - Problem of Diagnosis and Assessment: What is the  **standard** against which
   we can compare a given linear covariance adjustment specification?
 - Problem of extrapolation and interpolation: Often known as "common support",
   too.
 - Problems of overly influential points and curse of  dimensionality: As
   dimensions increase, odds of influential  point increase (ex. bell curve in
   one dimension, one very influential point in 2 dimensions); also real limits
   on number of covariates (roughly $\sqrt{n}$ for OLS).

## The Problem of Using  the Linear Model for  Adjustment

 - Problems of  bias even in randomized experiments:

\begin{equation}
Y_i = \beta_0 + \beta_1 Z_i + e_i
\label{eq:olsbiv}
\end{equation}

This is a common practice because, we know that the formula to estimate
$\beta_1$ in equation \eqref{eq:olsbiv} is the same as the difference of means
in $Y$ between treatment and control groups:

\begin{equation}
\hat{\beta}_1 = \overline{Y|Z=1} - \overline{Y|Z=0} = \frac{cov(Y,Z)}{var(Z)}.
\end{equation}

\begin{equation}
Y_i = \beta_0 + \beta_1 Z_i + \beta_2 X_i + e_i \label{eq:olscov}
\end{equation}

What is $\beta_1$ in this case? We know the matrix representation here $(\bX^{T}\bX)^{-1}\bX^{T}\by$, but here is the scalar formula for this particular case in \eqref{eq:olscov}:

\begin{equation}
\hat{\beta}_1 = \frac{\var(X)\cov(Z,Y) - \cov(X,Z)\cov(X,Y)}{\var(Z)\var(X) - \cov(Z,X)^2}
\end{equation}
-->

## Can we improve stratified adjustment?

Rather than two strata, why not three?

```{r lm1cut3, echo=TRUE}
lm1cut3 <- lm(HomRate08 ~ nhTrt + cut(nhAboveHS, 3), data = meddat)
coef(lm1cut3)["nhTrt"]
```
But why those cuts? And why not 4? Why not...?

**One idea:** collect observations into strata such that the sum of the
differences in means of `nhAboveHS` within strata is smallest? This is the idea
behind `optmatch` and other matching approaches.

## The optmatch workflow: The distance matrix

The `optmatch` workflow. To minimize differences requires a matrix
of those differences (in general terms, a matrix of distances between the
treated and control units)

```{r optm1, echo=TRUE}
tmp <- meddat$nhAboveHS
names(tmp) <- rownames(meddat)
absdist <- match_on(tmp, z = meddat$nhTrt, data = meddat)
absdist[1:3, 1:3]
abs(meddat$nhAboveHS[meddat$nhTrt == 1][1] - meddat$nhAboveHS[meddat$nhTrt == 0][1])
```

## Created a Stratified Research Design {.shrink}

Then delegate to an algorithm the optimization task of finding strata that
minimize the overall within-set differences:

```{r fm1, echo=TRUE}
fm1 <- fullmatch(absdist, data = meddat)
summary(fm1, min.controls = 0, max.controls = Inf)
table(meddat$nhTrt, fm1)

pm1 <- pairmatch(absdist, data = meddat)
summary(pm1, min.controls = 0, max.controls = Inf)
table(meddat$nhTrt, pm1, exclude = c())
```


## Evaluate the design: Within set differences

```{r echo=FALSE}
meddat$fm1 <- fm1
meddat$pm1 <- pm1
```

Differences within sets versus raw differences from the fullmatch.

```{r echo=FALSE, out.width=".9\\textwidth"}
library(gridExtra)
bpfm1 <- ggplot(meddat, aes(x = fm1, y = nhAboveHS)) +
  geom_boxplot() +
  stat_summary(fun = mean, geom = "point", shape = 20, size = 3, color = "red", fill = "red")
meddat$nostrata <- rep(1, 45)
bporig <- ggplot(meddat, aes(x = nostrata, y = nhAboveHS)) +
  geom_boxplot() +
  stat_summary(
    fun = mean, geom = "point",
    shape = 20, size = 3, color = "red", fill = "red"
  )

grid.arrange(bpfm1, bporig, ncol = 2, layout_matrix = matrix(c(1, 1, 1, 1, 2), nrow = 1))
```

## Evaluate the design: Within set differences

Differences within sets versus raw differences from the pairmatch.

```{r echo=FALSE, out.width=".9\\textwidth"}
bppm1 <- ggplot(meddat, aes(x = pm1, y = nhAboveHS)) +
  geom_boxplot() +
  stat_summary(fun = mean, geom = "point", shape = 20, size = 3, color = "red", fill = "red")

grid.arrange(bppm1, bporig, ncol = 2, layout_matrix = matrix(c(1, 1, 1, 1, 2), nrow = 1))
```

## Evaluate the design: Inspect within set differences

```{r sdiffs, echo=FALSE}
rawmndiffs <- with(meddat, mean(nhAboveHS[nhTrt == 1]) - mean(nhAboveHS[nhTrt == 0]))
setdiffsfm1 <- meddat %>%
  group_by(fm1) %>%
  summarize(
    mneddiffs =
      mean(nhAboveHS[nhTrt == 1]) -
        mean(nhAboveHS[nhTrt == 0]),
    mnAboveHS = mean(nhAboveHS),
    minAboveHS = min(nhAboveHS),
    maxAboveHS = max(nhAboveHS)
  )

setdiffsfm1
# summary(setdiffs$mneddiffs)
# quantile(setdiffs$mneddiffs, seq(0,1,.1))
```

## Evaluate the design: Inspect within set differences

```{r echo=FALSE, warnings=FALSE}
setdiffspm1 <- meddat %>%
  group_by(pm1) %>%
  summarize(
    mneddiffs =
      mean(nhAboveHS[nhTrt == 1]) -
        mean(nhAboveHS[nhTrt == 0]),
    mnAboveHS = mean(nhAboveHS),
    minAboveHS = min(nhAboveHS),
    maxAboveHS = max(nhAboveHS)
  )

setdiffspm1
```


## Evaluate the design: Compare to a randomized experiment.
The within-set differences look different from those that would be expected
from a randomized experiment.

```{r xbhs2, echo=TRUE}
xbfm1 <- balanceTest(nhTrt ~ nhAboveHS+strata(fm1), data = meddat)
xbfm1$results[,,]
xbfm1$overall
```



## What is balanceTest doing?

```{r xbagain, echo=TRUE}
setmeanDiffs <- meddat %>%
  group_by(fm1) %>%
  summarise(
    diffAboveHS = mean(nhAboveHS[nhTrt == 1]) - mean(nhAboveHS[nhTrt == 0]),
    nb = n(),
    nTb = sum(nhTrt),
    nCb = sum(1 - nhTrt),
    hwt = (2 * (nCb * nTb) / (nTb + nCb))
  )
setmeanDiffs
```

## What is balanceTest doing with multiple sets/blocks?

The test statistic is a weighted average of the set-specific differences (same
approach as we would use to test the null in a block-randomized experiment)

```{r wtmns, echo=TRUE}
## The descriptive mean difference using block-size weights
with(setmeanDiffs, sum(diffAboveHS * nTb / sum(nTb)))
## The mean diff used as the observed value in the testing
with(setmeanDiffs, sum(diffAboveHS * hwt / sum(hwt)))
## Compare to balanceTest output
xbfm1$results[, , "fm1"]
```

# Matching on Many Covariates: Using the Mahalnobis Distance to Scale Euclidean Distance

## The Curse of Dimensionality and visualizing linear adjustment for one more variable.

But first, look at how linear covariance adjustment would deal with multiple covariates.

\smallskip

What about more than one variable? Have we controlled for both population
density and educational attainment enough? How would we know?

```{r lm2x, echo=TRUE}
lm2x <- lm(HomRate08 ~ nhTrt + nhPopD + nhAboveHS, data = meddat)
coef(lm2x)["nhTrt"]
```

Maybe another plot? (see the 3d plots)

```{r scat3d, eval=TRUE}
meddat$nhTrtF <- factor(meddat$nhTrt)
library(car)
scatter3d(HomRate08 ~ nhAboveHS + nhPopD,
  groups = meddat$nhTrtF,
  data = meddat, surface = TRUE,
  fit = c("linear")
) # additive"))
```



## Dimension reduction using the Mahalanobis Distance

The general idea: dimension reduction. When we convert many columns into one
column we reduce the dimensions of the dataset (to one column). We can use the
idea of **multivariate distance** to produce distance matrices to minimize
**multivariate distances**.


```{r out.width=".7\\textwidth"}
X <- meddat[, c("nhAboveHS", "nhPopD")]
plot(meddat$nhAboveHS, meddat$nhPopD, xlim = c(-.3, .6), ylim = c(50, 700))
```

## Dimension reduction using the Mahalanobis Distance

First, let's look at Euclidean distance: $\sqrt{ (x_1 - x_2)^2 + (y_1 - y_2)^2 }$

```{r echo=FALSE, out.width=".8\\textwidth"}
par(mgp = c(1.25, .5, 0), oma = rep(0, 4), mar = c(3, 3, 0, 0))
plot(meddat$nhAboveHS, meddat$nhPopD, xlim = c(-.3, .6), ylim = c(50, 700))
points(mean(X[, 1]), mean(X[, 2]), pch = 19, cex = 1)
arrows(mean(X[, 1]), mean(X[, 2]), X["407", 1], X["407", 2])
text(.4, 200, label = round(dist(rbind(colMeans(X), X["407", ])), 2))
text(.3,100, label="Distance from the mean of both dimensions")
text(.3,75,bquote("(" * bar(x) * " = " * .(mean(X[,1])) * ", " *  bar(y) * " = " * .(mean(X[,2])) * ")"))
```

## Dimension reduction using the Mahalanobis Distance

First, let's look at Euclidean distance: $\sqrt{ (x_1 - x_2)^2 + (y_1 - y_2)^2 }$

```{r echo=FALSE, out.width=".5\\textwidth"}
par(mgp = c(1.25, .5, 0), oma = rep(0, 4), mar = c(3, 3, 0, 0))
plot(meddat$nhAboveHS, meddat$nhPopD, xlim = c(-.3, .6), ylim = c(50, 700))
points(mean(X[, 1]), mean(X[, 2]), pch = 19, cex = 1)
arrows(mean(X[, 1]), mean(X[, 2]), X["407", 1], X["407", 2])
text(.4, 200, label = round(dist(rbind(colMeans(X), X["407", ])), 2))
```

Distance between point in middle of the plot and unit "407".

```{r, echo=TRUE}
tmp <- rbind(colMeans(X), X["407", ])
tmp
sqrt((tmp[1, 1] - tmp[2, 1])^2 + (tmp[1, 2] - tmp[2, 2])^2)
```

Problem: overweights variables with bigger scales (Population Density dominates here).

## Dimension reduction using the Mahalanobis Distance

Now the standardized Euclidean distance so neither variable is overly dominant.

```{r echo=TRUE}
Xsd <- scale(X)
apply(Xsd, 2, sd) ## should be 1
round(apply(Xsd, 2, mean),8) ## should be 0
```

```{r echo=FALSE,out.width=".6\\textwidth"}
plot(Xsd[, 1], Xsd[, 2], xlab = "nhAboveHS/sd", ylab = "nhPopD/sd")
points(mean(Xsd[, 1]), mean(Xsd[, 2]), pch = 19, cex = 1)
arrows(mean(Xsd[, 1]), mean(Xsd[, 2]), Xsd["407", 1], Xsd["407", 2])
text(2, -1.2, label = round(dist(rbind(colMeans(Xsd), Xsd["407", ])), 2))
```


## Dimension reduction using the Mahalanobis Distance

The mahalanobis distance avoids the scale problem in the euclidean distance.^[For more [see here](https://stats.stackexchange.com/questions/62092/bottom-to-top-explanation-of-the-mahalanobis-distance)] Here each circle are points of the same MH distance.

```{r mhfig, echo=FALSE,out.width=".6\\textwidth"}
library(chemometrics) ## for drawMahal
library(mvtnorm)

par(mgp = c(1.5, .5, 0), oma = rep(0, 4), mar = c(3, 3, 0, 0))
mh <- mahalanobis(X, center = colMeans(X), cov = cov(X))
drawMahal(X,
  center = colMeans(X), covariance = cov(X),
  quantile = c(0.975, 0.75, 0.5, 0.25)
)
abline(v = mean(meddat$nhAboveHS), h = mean(meddat$nhPopD))
pts <- c("401", "407", "411", "202")
arrows(rep(mean(X[, 1]), 4), rep(mean(X[, 2]), 4), X[pts, 1], X[pts, 2])
text(X[pts, 1], X[pts, 2], labels = round(mh[pts], 2), pos = 1)
```

```{r}
Xsd <- scale(X)
tmp <- rbind(c(0, 0), Xsd["407", ])
mahalanobis(tmp, center = c(0, 0), cov = cov(Xsd))
## It is different from Euclidean distance
edist <- sqrt((tmp[1, 1] - tmp[2, 1])^2 + (tmp[1, 2] - tmp[2, 2])^2)
edist
```


## How is Mahalanobis distance different from Scaled Euclidean Distance?

To Review: The Mahalanobis distance \citep{mahalanobis1930test}, avoids the scale and correlation problem in the euclidean distance.^[For more see <https://stats.stackexchange.com/questions/62092/bottom-to-top-explanation-of-the-mahalanobis-distance>] $dist_M =  \sqrt{ (\mathbf{x} - \mathbf{\bar{x}})^T \mathbf{M}^{-1} (\mathbf{y} - \mathbf{\bar{y}}) }$ where $\mathbf{M}=\begin{bmatrix} \var(x) & \cov(x,y)  \\ \cov(x,y) & \var(y) \end{bmatrix}$


Here, using simulated data: The contour lines show points with the same
Mahalanobis distance and the numbers are Euclidean distance.

```{r}
set.seed(12345)
newX <- rmvnorm(n=45,mean=colMeans(X),sigma=matrix(c(.03,-7,-7,14375),2,2))
row.names(newX) <- row.names(X)
#plot(newX)
cor(newX)
```

```{r echo=FALSE, out.width=".4\\textwidth"}
mhnew <- mahalanobis(newX,center=colMeans(newX),cov=cov(newX))
drawMahal(newX,center=colMeans(newX),covariance=cov(newX),
          quantile = c(0.975, 0.75, 0.5, 0.25))
abline(v=mean(newX[,1]),h=mean(newX[,2]),col="gray")
points(mean(newX[,1]),mean(newX[,2]),pch=19,cex=1)
newpts <- c(3,16,17,20,22,30,42)
row.names(newX[newpts,])
arrows(mean(newX[,1]),mean(newX[,2]),newX[newpts,1],newX[newpts,2],length=.1)
edist <- as.matrix(dist(rbind(centers=colMeans(newX),newX[newpts,])))
text(newX[newpts,1]-.02,newX[newpts,2]-10,
     label=round(edist[-1,"centers"],2),font=2)
```

## Dimension reduction using the Mahalanobis distance

The contour lines show points with the same
Mahalanobis distance, the numbers are Euclidean distance. Notice that the point with Euclidean distance of 161 is farther from the center than 250 in Mahalanobis terms.

```{r echo=FALSE, results="hide", out.width=".75\\textwidth"}
mhnew <- mahalanobis(newX,center=colMeans(newX),cov=cov(newX))
drawMahal(newX,center=colMeans(newX),covariance=cov(newX),
          quantile = c(0.975, 0.75, 0.5, 0.25))
abline(v=mean(newX[,1]),h=mean(newX[,2]),col="gray")
points(mean(newX[,1]),mean(newX[,2]),pch=19,cex=1)
newpts <- c(3,16,17,20,22,30,42)
row.names(newX[newpts,])
arrows(mean(newX[,1]),mean(newX[,2]),newX[newpts,1],newX[newpts,2],length=.1)
edist <- as.matrix(dist(rbind(centers=colMeans(newX),newX[newpts,])))
text(newX[newpts,1]-.02,newX[newpts,2]-10,
     label=round(edist[-1,"centers"],2),font=2)
```


## Dimension reduction using the Mahalanobis distance

The contour lines show points with the same
Mahalanobis distance and the numbers are Euclidean distance (**now on the
standardized variables**). (notice that 1.63 is farther from the center in
Mahalanobis terms than 2.11, but 2.11 is farther in Eucliean terms.)


```{r echo=FALSE}
newXsd <- scale(newX)
drawMahal(newXsd,center=colMeans(newXsd),covariance=cov(newXsd),
          quantile = c(0.975, 0.75, 0.5, 0.25))
abline(v=mean(newXsd[,1]),h=mean(newXsd[,2]),col="gray")
points(mean(newXsd[,1]),mean(newXsd[,2]),pch=19,cex=1)
arrows(mean(newXsd[,1]),mean(newXsd[,2]),newXsd[newpts,1],newXsd[newpts,2],length=.1)
edistSd <- as.matrix(dist(rbind(centers=colMeans(newXsd),newXsd[newpts,])))
text(newXsd[newpts,1]-.1,newXsd[newpts,2]-.1,
     label=round(edistSd[-1,"centers"],2),font=2)
```

Basic point: Mahalanobis distance standardized *both* by univariate variance *and* covariance.

## Matching on the Mahalanobis Distance

Here using the rank based Mahalanobis distance following DOS Chap. 8 (but comparing to the ordinary version).

```{r echo=TRUE}
mhdist <- match_on(nhTrt ~ nhPopD + nhAboveHS, data = meddat, method = "rank_mahalanobis")
mhdist[1:3, 1:3]
mhdist2 <- match_on(nhTrt ~ nhPopD + nhAboveHS, data = meddat)
mhdist2[1:3, 1:3]
mhdist2[, "407"]
```

## Matching on the Mahalanobis Distance

Here using the rank based Mahalanobis distance following DOS Chap. 8 (but comparing to the ordinary version).

```{r out.width=".5\\textwidth"}
par(mgp = c(1.5, .5, 0), oma = rep(0, 4), mar = c(3, 3, 0, 0))
drawMahal(X,
  center = colMeans(X), covariance = cov(X),
  quantile = c(0.975, 0.75, 0.5, 0.25)
)
abline(v = mean(meddat$nhAboveHS), h = mean(meddat$nhPopD))
cpts <- c("401", "407", "411")
tpts <- c("101", "102", "202")
arrows(X[tpts, 1], X[tpts, 2], rep(X["407", 1]), rep(X["407", 2]))
text(X[tpts, 1], X[tpts, 2], labels = round(mhdist2[tpts, "407"], 2), pos = 1)
```

```{r echo=TRUE}
mhdist2[tpts, "407"]
```

## Matching on the Mahalanobis Distance

```{r echo=TRUE}
mhdist <- match_on(nhTrt ~ nhPopD + nhAboveHS, data = meddat, method = "rank_mahalanobis")

fmMh <- fullmatch(mhdist, data = meddat)
summary(fmMh, min.controls = 0, max.controls = Inf)
summary(unlist(matched.distances(fmMh,mhdist)))
```


```{r intro_caliper, eval=FALSE}
quantile(as.vector(mhdist),seq(0,1,.1))
mhdistCal1 <- mhdist + caliper(mhdist,2)
mhdistCal1[1:5,1:5]
fmMh1 <- fullmatch( mhdistCal1, data = meddat) #, min.controls = 1)
summary(fmMh1, min.controls = 0, max.controls = Inf)
summary(unlist(matched.distances(fmMh1,mhdist)))

```

## Matching on the Mahalanobis Distance

```{r echo=TRUE}
xbMh <- balanceTest(nhTrt ~ nhAboveHS + nhPopD+strata(fmMh),  data = meddat)
xbMh$results[,,]
xbMh$overall
```


#  Matching on Many Covariates: Using Propensity Scores to Summarize Covariate to Treatment Relationships


## The propensity score

Given covariates $\mathbf{x} (=(x_1, \ldots, x_k))$, and a
treatment variable $Z$, $Z(u) \in \{0, 1\}$,  $\PP (Z \vert \mathbf{x})$ is known as the (true) \textbf{propensity score} (PS).
$$ \phi( \mathbf{x} ) \equiv \log\left( \PP (Z=1 \vert \mathbf{x})/\PP (Z=0 \vert \mathbf{x}) \right)$$
is also known as the PS.  In practice, one works
with an estimated PS, $\hat{\PP} (Z \vert \mathbf{x})$ or
$\hat{\phi}(\mathbf{x})$.

Theoretically, propensity-score strata or matched sets both

 1. reduce extrapolation; and
 2. balance each of $x_1, \ldots, x_k$.

They do this by making the comparison more "experiment-like", at least in terms of $x_1, \ldots, x_k$.

Theory @rosrub83 also tells us that in the **absence of hidden bias**, such a stratification
supports unbiased estimation of treatment effects.


## Propensity scoring in practice

 - Fitted propensity scores help identify extrapolation.
 - In practice, stratification on $\hat{\phi}(\mathbf{x})$ helps balance each
   of $x_1, \ldots, x_k$ compared to no stratification.


There are \emph{lots of cases} in which adjustment with the propensity score alone fails to generate estimates that agree with those of randomized studies.

There are various reasons for this, starting with:

 - lots of observational studies that don't measure quite enough $x$es or the
   right $x$es or the right $x$es in the right way
 - **hidden biases** --- propensity scores address bias on measured variables,
   not unmeasured ones.

## Intuition about the propensity score

A propensity score is the output of a function of covariates as they relate to
$Z$ (the "treatment" or "intervention"). Why reduce the dimension of $\mathbf{x}$
in this way rather than, say, using Mahalanobis distance?

\medskip

Recall that an experiment breaks the relationship between $Z$ and
$\mathbf{x}=\{ x_1,x_2,\ldots \}$ but not between $\mathbf{x}$ and $Y$ or
$y_1,y_0$.

\includegraphics[width=.25\textwidth]{xyzdiagram.pdf}

```{r tikzarrows, eval=FALSE, include=FALSE, engine='tikz', engine.opts=list(template="icpsr-tikz2pdf.tex")}
\usetikzlibrary{arrows}
\begin{tikzcd}[ampersand replacement=\&, column sep=small]
  Z  \arrow[from=1-1,to=1-3] &                               & Y \\
  &   \mathbf{x} \arrow[from=2-2,to=1-1, "\text{0 if Z rand}"] \arrow[from=2-2,to=1-3] &
\end{tikzcd}
```

Making strata of units who are similar on the propensity score reduces (or removes)
the relationship between $Z$ and the relevant $\mathbf{x}$ within strata (either the
units have similar values for $\mathbf{x}$ or the particular $x$s which do not have a
strong (linear, additive) relationship with $Z$).

## Matching on the propensity score

**Make the score** (Note that we will be using `brglm` or `bayesglm` in the
future because of logit separation problems when the number of covariates
increases.)

```{r}
theglm <- glm(nhTrt ~ nhPopD + nhAboveHS, data = meddat, family = binomial(link = "logit"))
thepscore <- theglm$linear.predictor
thepscore01 <- predict(theglm, type = "response")
```

We tend to match on the linear predictor rather than the version required to
range only between 0 and 1. Recall how distance matrices required choices of
distance metrics? We don't want to categorize two observations as "close" just
because the logit function squashed them together near 0 or 1.

```{r echo=FALSE, out.width=".65\\textwidth"}
par(mfrow = c(1, 2), oma = rep(0, 4), mar = c(3, 3, 2, 0), mgp = c(1.5, .5, 0))
boxplot(split(thepscore, meddat$nhTrt), main = "Linear Predictor (XB)")
stripchart(split(thepscore, meddat$nhTrt), add = TRUE, vertical = TRUE)

boxplot(split(thepscore01, meddat$nhTrt), main = "Inverse Link Function (g^-1(XB))")
stripchart(split(thepscore01, meddat$nhTrt), add = TRUE, vertical = TRUE)
```


## Matching on the propensity score: What do the distance matrix entries mean?

optmatch creates a scaled propensity score distance by default --- scaling by, roughly, the pooled median absolute deviation of the covariate (or here, the propensity score). So, the distance matrix entries are like standard deviations  --- standardized scores.

```{r echo=TRUE}
## Create a distance matrix using the propensity scores
psdist <- match_on(theglm, data = meddat)
psdist[1:4, 1:4]
```

What do those distances mean?
```{r}
simpdist <- outer(thepscore, thepscore, function(x, y) {
  abs(x - y)
})
mad(thepscore[meddat$nhTrt == 1])
mad(thepscore[meddat$nhTrt == 0])
(mad(thepscore[meddat$nhTrt == 1]) + mad(thepscore[meddat$nhTrt == 0])) / 2
## We can see the actual R function here: optmatch:::match_on_szn_scale
## optmatch:::match_on_szn_scale(thepscore, Tx = meddat$nhTrt)
simpdist["101", c("401", "402", "403")]
simpdist["101", c("401", "402", "403")] / .9137
psdist["101", c("401", "402", "403")]
```


## Matching on the propensity score

The following design balances the two covariates used in the creation of the
propensity score well. It does not balance the baseline outcome well (not that
we assumed it would, but demonstrating here that the covariates used for the
creation of the design need not necessarily be all of those used to
**evaluate** the design).

```{r}
fmPs <- fullmatch(psdist, data = meddat)
summary(fmPs, min.controls = 0, max.controls = Inf,propensity.model=theglm)
meddat$fmPs <- factor(fmPs)

xb2 <- balanceTest(nhTrt ~ nhPopD + nhAboveHS+strata(fmPs), data = meddat)
xb2$overall[, ]
xb2$results[,,]

xb2a <- xBalance(nhTrt ~ nhPopD + nhAboveHS + HomRate03,
  strata = list(fmPs = ~fmPs), data = meddat,
  report = "all"
)
xb2a$overall[, ]
```

Compare to Mahalanobis distance:

```{r}
mh_dist <- match_on(nhTrt ~ nhPopD + nhAboveHS,
  data = meddat,
  method = "rank_mahalanobis"
)
fmMh <- fullmatch(mh_dist, data = meddat)
summary(fmMh)
xb3 <- xBalance(nhTrt ~ nhPopD + nhAboveHS + HomRate03,
  strata = list(unstrat = NULL, fmPs = ~fmPs, fmMh = ~fmMh), data = meddat,
  report = "all"
)
xb3$overall[, ]
xb3$results[, "std.diff", ]
```

```{r}
plot(xb3, ggplot = TRUE) + theme_classic()
```

# Matching Tricks of the Trade: Calipers, Exact Matching

## Calipers

The optmatch package allows calipers (which forbids certain pairs from being matched).^[You can implement penalties by hand.] Here, for example, we forbid comparisons which differ by more than 2 propensity score standardized distances.

```{r}
## First inspect the distance matrix itself: how are the distances distributed?
quantile(as.vector(psdist), seq(0, 1, .1))
## Next, apply a caliper (setting entries to Infinite)
psdistCal <- psdist + caliper(psdist, 2)
as.matrix(psdist)[5:10, 5:10]
as.matrix(psdistCal)[5:10, 5:10]
summary(psdistCal)
```
## Calipers

The optmatch package allows calipers (which forbid certain pairs from being
matched).^[You can implement penalties by hand.] Here, for example, we forbid
comparisons which differ by more than 2 standard deviations on the propensity
score. (Notice that we also use the `propensity.model` option to `summary` here
to get a quick look at the balance test:)

```{r}
fmCal1 <- fullmatch(psdist + caliper(psdist, 2), data = meddat, tol = .00001)
summary(fmCal1, min.controls = 0, max.controls = Inf, propensity.model = theglm)
pmCal1 <- pairmatch(psdist + caliper(psdist, 2), data = meddat, remove.unmatchables = TRUE)
summary(pmCal1, propensity.model = theglm)
```

## Calipers

Another example: We may want to match on mahalanobis distance but disallow any
pairs with extreme propensity distance and/or extreme differences in baseline
homicide rates (here using many covariates all together).


```{r}
## Create an R formulate object from vectors of variable names
balfmla <- reformulate(c("nhPopD", "nhAboveHS"), response = "nhTrt")

## Create a mahalanobis distance matrix (of rank transformed data)
mhdist <- match_on(balfmla, data = meddat, method = "rank_mahalanobis")

## Now make a matrix recording absolute differences between neighborhoods in
## terms of baseline homicide rate
tmpHom03 <- meddat$HomRate03
names(tmpHom03) <- rownames(meddat)
absdist <- match_on(tmpHom03, z = meddat$nhTrt, data = meddat)
absdist[1:3, 1:3]
quantile(as.vector(absdist), seq(0, 1, .1))
quantile(as.vector(mhdist),seq(0,1,.1))
## Now create a new distance matrix using two calipers:
distCal <- psdist + caliper(mhdist, 9) + caliper(absdist, 2)
as.matrix(distCal)[5:10, 5:10]
## Compare to:
as.matrix(mhdist)[5:10, 5:10]
```

## Calipers

Now, use this new matrix for the creation of stratified designs --- but possibly excluding some units (also showing here the `tol` argument. The version with the tighter tolerance produces a solution with smaller overall distances)

```{r}
fmCal2a <- fullmatch(distCal, data = meddat, tol = .001)
summary(fmCal2a, min.controls = 0, max.controls = Inf)
fmCal2b <- fullmatch(distCal, data = meddat, tol = .00001)
summary(fmCal2b, min.controls = 0, max.controls = Inf, propensity.model=theglm)

meddat$fmCal2a <- fmCal2a
meddat$fmCal2b <- fmCal2b

fmCal2a_dists <- matched.distances(fmCal2a, distCal)
fmCal2b_dists <- matched.distances(fmCal2b, distCal)

mean(unlist(fmCal2a_dists))
mean(unlist(fmCal2b_dists))
```

## Exact Matching

We often have covariates that are categorical/nominal and for which we really care about strong balance. One approach to solve this problem is match **exactly** on one or more of such covariates. If `fullmatch` or `match_on` is going slow, this is also an approach to speed things up.

```{r echo=FALSE}
meddat$classLowHi <- ifelse(meddat$nhClass %in% c(2, 3), "hi", "lo")
```

```{r}
dist2 <- psdist + exactMatch(nhTrt ~ classLowHi, data = meddat)
summary(dist2)
## or mhdist <- match_on(balfmla,within=exactMatch(nhTrt~classLowHi,data=meddat),data=meddat,method="rank_mahalanobis")
## or fmEx1 <- fullmatch(update(balfmla,.~.+strata(classLowHi)),data=meddat,method="rank_mahalanobis")
fmEx1 <- fullmatch(dist2, data = meddat, tol = .00001)
summary(fmEx1, min.controls = 0, max.controls = Inf, propensity.model=theglm)
print(fmEx1, grouped = T)
meddat$fmEx1 <- fmEx1
```
## Exact Matching

```{r}
ftable(Class = meddat$classLowHi, Trt = meddat$nhTrt, fmEx1, col.vars = c("Class", "Trt"))
```

# Summary

## Summary of the Day

 - We can assess the randomization of a randomized experiment easily using
   covariates ($X$): compare the observed treatment-vs-control differences in
   $X$ with those consistent with differences that would emerge from repeating
   the design. (The differences will not be strictly zero. But shouldn't be
   systematically different.)

 - How to justify an adjustment strategy for an observational study? The
   linear model adjustment strategy is difficult to justify. A stratification
   based strategy is easier to justify, inspect, learn from. (We can compare
   our stratification to a block randomized experiment, to a known design, a
   known standard.)

 - How to choose a stratification? We can do it by hand. Or we can delegate to
   a computer (i.e. `optmatch`) --- we can think of it as an optimization
   problem and ask the computer to optimize.


# References

